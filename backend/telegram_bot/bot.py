"""
Bot Telegram pour g√©rer l'acc√®s aux canaux priv√©s
"""
import os
import logging
import django
from datetime import timedelta

# Configuration Django
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'backend.settings')
django.setup()

from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes, ChatMemberHandler
from django.utils import timezone
from django.conf import settings

from accounts.models_telegram import TelegramBotToken, TelegramChannelInvite, TelegramChannelMember, TelegramNotification

# Configuration du logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Configuration
BOT_TOKEN = settings.TELEGRAM_BOT_TOKEN
CHANNEL_ID = settings.TELEGRAM_CHANNEL_ID
CHANNEL_NAME = settings.TELEGRAM_CHANNEL_NAME

class CalmnessTradingBot:
    """Bot Telegram pour Calmness Trading"""
    
    def __init__(self):
        self.application = Application.builder().token(BOT_TOKEN).build()
        self._setup_handlers()
    
    def _setup_handlers(self):
        """Configurer les handlers du bot"""
        # Commande /start avec token
        self.application.add_handler(CommandHandler("start", self.start_command))
        
        # Commande /help
        self.application.add_handler(CommandHandler("help", self.help_command))
        
        # Commande /status
        self.application.add_handler(CommandHandler("status", self.status_command))
        
        # Handler pour les nouveaux membres du canal
        self.application.add_handler(ChatMemberHandler(self.track_member_update, ChatMemberHandler.CHAT_MEMBER))
        
        # Handler pour les messages non reconnus
        self.application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, self.unknown_message))
    
    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """
        Commande /start - Point d'entr√©e principal
        Format: /start TOKEN_UNIQUE
        """
        user = update.effective_user
        chat_id = update.effective_chat.id
        
        logger.info(f"üöÄ /start re√ßu de {user.username} (ID: {user.id})")
        
        # V√©rifier si un token est fourni
        if not context.args:
            await self.send_welcome_message(update, context)
            return
        
        # R√©cup√©rer le token
        token = context.args[0]
        
        try:
            # V√©rifier le token dans la base de donn√©es
            bot_token = TelegramBotToken.objects.get(token=token)
            
            # V√©rifier si le token est valide
            if not bot_token.is_valid():
                if bot_token.status == 'used':
                    await update.message.reply_text(
                        "‚ùå Ce token a d√©j√† √©t√© utilis√©.\n\n"
                        "Si vous avez d√©j√† acc√®s au canal, vous devriez le retrouver dans vos canaux Telegram."
                    )
                elif bot_token.status == 'expired':
                    await update.message.reply_text(
                        "‚ùå Ce token a expir√©.\n\n"
                        "Veuillez contacter notre support pour obtenir un nouveau lien d'acc√®s."
                    )
                else:
                    await update.message.reply_text(
                        "‚ùå Ce token n'est plus valide.\n\n"
                        "Veuillez contacter notre support pour obtenir un nouveau lien d'acc√®s."
                    )
                return
            
            # Marquer le token comme utilis√©
            bot_token.mark_as_used(user.id, user.username)
            
            # Mettre √† jour le telegram_username de l'utilisateur si n√©cessaire
            if user.username and bot_token.user.telegram_username != f"@{user.username}":
                bot_token.user.telegram_username = f"@{user.username}"
                bot_token.user.save()
            
            # Envoyer un message de bienvenue
            await update.message.reply_text(
                f"‚úÖ **Bienvenue {user.first_name}!**\n\n"
                f"Votre paiement a √©t√© v√©rifi√© avec succ√®s.\n\n"
                f"üéâ G√©n√©ration de votre lien d'acc√®s priv√© au canal **{CHANNEL_NAME}**...",
                parse_mode='Markdown'
            )
            
            # G√©n√©rer le lien d'invitation unique
            invite_link = await self.create_channel_invite(bot_token, user)
            
            if invite_link:
                # Cr√©er l'entr√©e dans la base de donn√©es
                channel_invite = TelegramChannelInvite.objects.create(
                    user=bot_token.user,
                    bot_token=bot_token,
                    channel_id=CHANNEL_ID,
                    channel_name=CHANNEL_NAME,
                    invite_link=invite_link,
                    telegram_user_id=user.id,
                    expires_at=timezone.now() + timedelta(minutes=5)
                )
                channel_invite.mark_as_sent()
                
                # Envoyer le lien d'invitation
                keyboard = [[InlineKeyboardButton("üîó Rejoindre le Canal", url=invite_link)]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                
                await update.message.reply_text(
                    f"üéØ **Votre lien d'acc√®s priv√© est pr√™t!**\n\n"
                    f"üîí Ce lien est **unique** et **expire dans 5 minutes**.\n"
                    f"‚ö†Ô∏è Il ne peut √™tre utilis√© qu'**une seule fois**.\n\n"
                    f"üëá Cliquez sur le bouton ci-dessous pour rejoindre le canal :",
                    reply_markup=reply_markup,
                    parse_mode='Markdown'
                )
                
                # Cr√©er une notification
                TelegramNotification.objects.create(
                    user=bot_token.user,
                    notification_type='invite_sent',
                    title='Lien d\'acc√®s envoy√©',
                    message=f'Lien d\'acc√®s au canal {CHANNEL_NAME} envoy√© avec succ√®s',
                    action_url=invite_link,
                    metadata={'channel_id': CHANNEL_ID, 'telegram_user_id': user.id}
                ).mark_as_sent(via_telegram=True)
                
                logger.info(f"‚úÖ Lien d'invitation envoy√© √† {user.username}")
            else:
                await update.message.reply_text(
                    "‚ùå Erreur lors de la g√©n√©ration du lien d'invitation.\n\n"
                    "Veuillez contacter notre support."
                )
                logger.error(f"‚ùå √âchec de g√©n√©ration du lien pour {user.username}")
        
        except TelegramBotToken.DoesNotExist:
            await update.message.reply_text(
                "‚ùå Token invalide.\n\n"
                "Veuillez v√©rifier que vous avez cliqu√© sur le bon lien."
            )
            logger.warning(f"‚ö†Ô∏è Token invalide re√ßu : {token}")
    
    async def create_channel_invite(self, bot_token, telegram_user):
        """
        Cr√©er un lien d'invitation unique pour le canal
        """
        try:
            # Cr√©er le lien d'invitation
            invite_link = await self.application.bot.create_chat_invite_link(
                chat_id=CHANNEL_ID,
                member_limit=1,  # Une seule personne peut utiliser ce lien
                expire_date=int((timezone.now() + timedelta(minutes=5)).timestamp())  # Expire dans 5 minutes
            )
            
            return invite_link.invite_link
        except Exception as e:
            logger.error(f"‚ùå Erreur cr√©ation lien d'invitation : {e}")
            return None
    
    async def send_welcome_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Envoyer un message de bienvenue"""
        user = update.effective_user
        
        await update.message.reply_text(
            f"üëã **Bienvenue sur le bot Calmness Trading!**\n\n"
            f"üîê Pour acc√©der √† nos canaux priv√©s, vous devez :\n\n"
            f"1Ô∏è‚É£ Effectuer un paiement sur notre site\n"
            f"2Ô∏è‚É£ Attendre la validation par notre √©quipe\n"
            f"3Ô∏è‚É£ Cliquer sur le lien unique que vous recevrez\n\n"
            f"üí° **Besoin d'aide?**\n"
            f"Utilisez la commande /help pour plus d'informations.",
            parse_mode='Markdown'
        )
    
    async def help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Commande /help"""
        await update.message.reply_text(
            "üÜò **Aide - Bot Calmness Trading**\n\n"
            "**Commandes disponibles:**\n"
            "‚Ä¢ /start - D√©marrer le bot\n"
            "‚Ä¢ /help - Afficher cette aide\n"
            "‚Ä¢ /status - V√©rifier votre statut d'abonnement\n\n"
            "**Questions fr√©quentes:**\n\n"
            "‚ùì *Comment acc√©der au canal?*\n"
            "Effectuez un paiement sur notre site et attendez la validation.\n\n"
            "‚ùì *Mon lien ne fonctionne pas?*\n"
            "Les liens expirent apr√®s 5 minutes. Contactez le support pour un nouveau lien.\n\n"
            "‚ùì *Comment contacter le support?*\n"
            "Rendez-vous sur notre site : https://calmnesstrading.vercel.app",
            parse_mode='Markdown'
        )
    
    async def status_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Commande /status - V√©rifier le statut d'abonnement"""
        user = update.effective_user
        
        try:
            # Chercher les memberships de l'utilisateur
            memberships = TelegramChannelMember.objects.filter(
                telegram_user_id=user.id,
                status='active'
            )
            
            if memberships.exists():
                membership = memberships.first()
                days_remaining = (membership.subscription_end_date - timezone.now()).days
                
                status_emoji = "‚úÖ" if days_remaining > 7 else "‚ö†Ô∏è" if days_remaining > 0 else "‚ùå"
                
                await update.message.reply_text(
                    f"{status_emoji} **Statut de votre abonnement**\n\n"
                    f"üìä Type: {membership.subscription_type}\n"
                    f"üìÖ Fin: {membership.subscription_end_date.strftime('%d/%m/%Y')}\n"
                    f"‚è≥ Jours restants: {days_remaining}\n\n"
                    f"{'‚ö†Ô∏è Votre abonnement expire bient√¥t! Pensez √† le renouveler.' if days_remaining <= 7 else ''}",
                    parse_mode='Markdown'
                )
            else:
                await update.message.reply_text(
                    "‚ùå **Aucun abonnement actif trouv√©**\n\n"
                    "Veuillez effectuer un paiement sur notre site pour acc√©der aux canaux priv√©s.\n\n"
                    "üåê Site: https://calmnesstrading.vercel.app",
                    parse_mode='Markdown'
                )
        except Exception as e:
            logger.error(f"‚ùå Erreur status_command : {e}")
            await update.message.reply_text(
                "‚ùå Erreur lors de la v√©rification de votre statut.\n\n"
                "Veuillez r√©essayer plus tard."
            )
    
    async def track_member_update(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """
        Suivre les entr√©es/sorties des membres du canal
        """
        chat_member_update = update.chat_member
        user = chat_member_update.new_chat_member.user
        old_status = chat_member_update.old_chat_member.status
        new_status = chat_member_update.new_chat_member.status
        
        logger.info(f"üë§ Mise √† jour membre : {user.username} ({old_status} ‚Üí {new_status})")
        
        # Si l'utilisateur rejoint le canal
        if old_status in ['left', 'kicked'] and new_status in ['member', 'administrator', 'creator']:
            logger.info(f"‚úÖ {user.username} a rejoint le canal")
            
            try:
                # Trouver l'invitation correspondante
                invite = TelegramChannelInvite.objects.filter(
                    telegram_user_id=user.id,
                    channel_id=chat_member_update.chat.id,
                    status='sent'
                ).order_by('-created_at').first()
                
                if invite:
                    invite.mark_as_accepted()
                    
                    # R√©cup√©rer les informations de l'offre depuis le bot_token
                    bot_token = invite.bot_token
                    
                    # R√©cup√©rer la dur√©e de l'abonnement depuis l'offre
                    from payments.models import Payment
                    try:
                        payment = Payment.objects.filter(id=bot_token.payment_id).first()
                        if payment and payment.offer:
                            # Utiliser la dur√©e de l'offre (en jours, heures ou minutes)
                            offer = payment.offer
                            subscription_type = offer.name
                            
                            # Calculer la date de fin selon la dur√©e de l'offre
                            if hasattr(offer, 'duration_days') and offer.duration_days:
                                subscription_end_date = timezone.now() + timedelta(days=offer.duration_days)
                            elif hasattr(offer, 'duration_hours') and offer.duration_hours:
                                subscription_end_date = timezone.now() + timedelta(hours=offer.duration_hours)
                            elif hasattr(offer, 'duration_minutes') and offer.duration_minutes:
                                subscription_end_date = timezone.now() + timedelta(minutes=offer.duration_minutes)
                            else:
                                # Par d√©faut 30 jours si pas de dur√©e sp√©cifi√©e
                                subscription_end_date = timezone.now() + timedelta(days=30)
                        else:
                            subscription_type = 'Abonnement'
                            subscription_end_date = timezone.now() + timedelta(days=30)
                    except Exception as e:
                        logger.error(f"‚ùå Erreur r√©cup√©ration offre : {e}")
                        subscription_type = 'Abonnement'
                        subscription_end_date = timezone.now() + timedelta(days=30)
                    
                    # Utiliser le username Telegram valid√© lors du paiement
                    telegram_username = user.username or ''
                    if not telegram_username and invite.user.telegram_username:
                        telegram_username = invite.user.telegram_username.replace('@', '')
                    
                    # Cr√©er ou mettre √† jour le membership
                    membership, created = TelegramChannelMember.objects.update_or_create(
                        user=invite.user,
                        channel_id=chat_member_update.chat.id,
                        defaults={
                            'telegram_user_id': user.id,
                            'telegram_username': telegram_username,
                            'channel_name': CHANNEL_NAME,
                            'status': 'active',
                            'subscription_type': subscription_type,
                            'subscription_end_date': subscription_end_date,
                            'expires_at': subscription_end_date,
                            'invite': invite
                        }
                    )
                    
                    # Cr√©er une notification
                    TelegramNotification.objects.create(
                        user=invite.user,
                        notification_type='access_granted',
                        title='Acc√®s accord√©',
                        message=f'Acc√®s au canal {CHANNEL_NAME} accord√© avec succ√®s',
                        metadata={'channel_id': chat_member_update.chat.id, 'telegram_user_id': user.id}
                    ).mark_as_sent(via_telegram=True)
                    
                    logger.info(f"‚úÖ Membership cr√©√© pour {user.username}")
            except Exception as e:
                logger.error(f"‚ùå Erreur track_member_update (join) : {e}")
        
        # Si l'utilisateur quitte le canal
        elif old_status in ['member', 'administrator'] and new_status in ['left', 'kicked']:
            logger.info(f"‚ùå {user.username} a quitt√© le canal")
            
            try:
                membership = TelegramChannelMember.objects.filter(
                    telegram_user_id=user.id,
                    channel_id=chat_member_update.chat.id,
                    status='active'
                ).first()
                
                if membership:
                    membership.revoke_access('left')
                    logger.info(f"‚úÖ Membership r√©voqu√© pour {user.username}")
            except Exception as e:
                logger.error(f"‚ùå Erreur track_member_update (leave) : {e}")
    
    async def unknown_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """G√©rer les messages non reconnus"""
        await update.message.reply_text(
            "‚ùì Je n'ai pas compris votre message.\n\n"
            "Utilisez /help pour voir les commandes disponibles."
        )
    
    def run(self):
        """Lancer le bot"""
        logger.info("ü§ñ D√©marrage du bot Calmness Trading...")
        self.application.run_polling()

def main():
    """Point d'entr√©e principal"""
    bot = CalmnessTradingBot()
    bot.run()

if __name__ == '__main__':
    main()

